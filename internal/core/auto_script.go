package core

import (
	"fmt"
	"slices"
	"strings"
)

// GenerateAutoScript generates the auto.sh loop orchestration script
func GenerateAutoScript(config AutoConfig) string {
	var sb strings.Builder

	sb.WriteString(scriptHeader())
	sb.WriteString(scriptConfig(config))
	sb.WriteString(scriptValidation())
	sb.WriteString(scriptHelpers())
	sb.WriteString(scriptAIToolFunction())
	sb.WriteString(scriptMainLoop())
	sb.WriteString(scriptSummary())

	return sb.String()
}

func scriptHeader() string {
	return `#!/usr/bin/env bash
set -euo pipefail

# Auto Loop - Autonomous AI Coding (Ralph Wiggum methodology)
# Generated by aicof. Customize as needed.

`
}

func scriptConfig(config AutoConfig) string {
	return fmt.Sprintf(`# --- Configuration ---
MAX_ITERATIONS="${1:-%d}"
AI_TOOL="${AI_TOOL:-%s}"
PRD_FILE="%s/%s"
PROGRESS_FILE="%s/%s"
PROMPT_FILE="%s/%s"
PAUSE_SECONDS="${PAUSE_SECONDS:-2}"

`, config.MaxIterations, config.AITool,
		AutoDir, AutoPRDFile,
		AutoDir, AutoProgressFile,
		AutoDir, AutoPromptFile)
}

func scriptValidation() string {
	return `# --- Validation ---
if [ ! -f "$PRD_FILE" ]; then
  echo "ERROR: $PRD_FILE not found. Run 'aicof auto init' first."
  exit 1
fi

if [ ! -f "$PROMPT_FILE" ]; then
  echo "ERROR: $PROMPT_FILE not found."
  exit 1
fi

`
}

func scriptHelpers() string {
	return `# --- Helpers ---
log() {
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  echo "[$timestamp] $*" | tee -a "$PROGRESS_FILE"
}

get_remaining_tasks() {
  python3 -c "
import json
with open('$PRD_FILE') as f:
    data = json.load(f)
remaining = [t for t in data['tasks'] if t['status'] in ('pending', 'in_progress', 'blocked')]
print(len(remaining))
" 2>/dev/null || echo "unknown"
}

is_all_done() {
  local remaining
  remaining=$(get_remaining_tasks)
  [ "$remaining" = "0" ]
}

`
}

func scriptAIToolFunction() string {
	return `run_ai_tool() {
  case "$AI_TOOL" in
    claude)
      claude --print --dangerously-skip-permissions "$PROMPT_FILE"
      ;;
    amp)
      amp --prompt-file "$PROMPT_FILE"
      ;;
    cursor)
      echo "Cursor CLI autonomous mode not yet supported. Use claude or amp."
      return 1
      ;;
    codex)
      codex --prompt-file "$PROMPT_FILE" --auto
      ;;
    *)
      echo "ERROR: Unsupported AI tool: $AI_TOOL"
      echo "Supported: claude, amp, codex"
      return 1
      ;;
  esac
}

`
}

func scriptMainLoop() string {
	return `# --- Main Loop ---
log "Auto loop starting. Max iterations: $MAX_ITERATIONS. Tool: $AI_TOOL"

for ((i = 1; i <= MAX_ITERATIONS; i++)); do
  log "[iteration:$i] Starting iteration $i of $MAX_ITERATIONS"

  if is_all_done; then
    log "[iteration:$i] All tasks completed! Exiting loop."
    break
  fi

  log "[iteration:$i] Running $AI_TOOL..."
  if ! run_ai_tool; then
    log "[iteration:$i] ERROR: AI tool exited with error. Continuing to next iteration..."
  fi

  sleep "$PAUSE_SECONDS"
  log "[iteration:$i] Iteration $i complete."
done

`
}

func scriptSummary() string {
	return `# --- Summary ---
remaining=$(get_remaining_tasks)
log "Auto loop finished. Iterations run: $((i - 1)). Remaining tasks: $remaining"

if [ "$remaining" = "0" ]; then
  echo "All tasks completed successfully!"
else
  echo "Loop ended with $remaining tasks remaining."
  echo "Run 'aicof auto status' for details."
fi
`
}

// GetSupportedAITools returns the list of supported AI tools
func GetSupportedAITools() []string {
	return []string{"claude", "amp", "cursor", "codex"}
}

// IsValidAITool checks if the given tool name is supported
func IsValidAITool(tool string) bool {
	return slices.Contains(GetSupportedAITools(), strings.ToLower(tool))
}
