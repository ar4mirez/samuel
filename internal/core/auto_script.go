package core

import (
	"fmt"
	"slices"
	"strings"
)

// GenerateAutoScript generates the auto.sh loop orchestration script
func GenerateAutoScript(config AutoConfig) string {
	var sb strings.Builder

	sb.WriteString(scriptHeader())
	sb.WriteString(scriptConfig(config))
	sb.WriteString(scriptValidation())

	// Skip tool setup in docker-sandbox mode — tools are pre-installed
	if config.Sandbox != SandboxDockerSandbox {
		sb.WriteString(scriptSetup())
	}

	sb.WriteString(scriptAuthCheck())
	sb.WriteString(scriptHelpers())
	sb.WriteString(scriptAIToolFunction())
	sb.WriteString(scriptMainLoop())
	sb.WriteString(scriptSummary())

	return sb.String()
}

func scriptHeader() string {
	return `#!/usr/bin/env bash
set -euo pipefail

# Auto Loop - Autonomous AI Coding (Ralph Wiggum methodology)
# Generated by samuel. Customize as needed.

`
}

func scriptConfig(config AutoConfig) string {
	return fmt.Sprintf(`# --- Configuration ---
MAX_ITERATIONS="${1:-%d}"
AI_TOOL="${AI_TOOL:-%s}"
PRD_FILE="%s/%s"
PROGRESS_FILE="%s/%s"
PROMPT_FILE="%s/%s"
PAUSE_SECONDS="${PAUSE_SECONDS:-2}"
MAX_CONSECUTIVE_FAILURES="${MAX_CONSECUTIVE_FAILURES:-3}"

`, config.MaxIterations, config.AITool,
		AutoDir, AutoPRDFile,
		AutoDir, AutoProgressFile,
		AutoDir, AutoPromptFile)
}

func scriptValidation() string {
	return `# --- Validation ---
if [ ! -f "$PRD_FILE" ]; then
  echo "ERROR: $PRD_FILE not found. Run 'samuel auto init' first."
  exit 1
fi

if [ ! -f "$PROMPT_FILE" ]; then
  echo "ERROR: $PROMPT_FILE not found."
  exit 1
fi

`
}

func scriptSetup() string {
	return `# --- Setup: ensure AI tool is available ---
ensure_writable_home() {
  # When Docker runs --user UID:GID without /etc/passwd entry, HOME
  # defaults to "/" which is not writable. Set a safe fallback.
  if [ -n "${HOME:-}" ] && [ "$HOME" != "/" ] && [ -d "$HOME" ] && [ -w "$HOME" ]; then
    return 0
  fi
  export HOME="/tmp"
}

install_nodejs() {
  if command -v node &>/dev/null && command -v npm &>/dev/null; then
    return 0
  fi
  echo "Installing Node.js..."
  if [ "$(id -u)" = "0" ]; then
    if command -v apt-get &>/dev/null; then
      apt-get update -qq && apt-get install -y -qq nodejs npm curl >/dev/null 2>&1
    elif command -v apk &>/dev/null; then
      apk add --quiet nodejs npm curl >/dev/null 2>&1
    elif command -v yum &>/dev/null; then
      yum install -y -q nodejs npm curl >/dev/null 2>&1
    else
      echo "ERROR: Cannot install Node.js — unsupported package manager."
      echo "Use an image with Node.js pre-installed (e.g., node:lts)."
      exit 1
    fi
  else
    echo "ERROR: Node.js not found and cannot install as non-root user."
    echo "Use an image with Node.js pre-installed (e.g., node:lts) or run with --sandbox-image node:lts"
    exit 1
  fi
}

npm_install_tool() {
  local package="$1"
  if [ "$(id -u)" = "0" ]; then
    npm install -g "$package" 2>&1
  else
    local prefix="$HOME/.local"
    mkdir -p "$prefix"
    npm install --prefix "$prefix" -g "$package" 2>&1
    export PATH="$prefix/bin:$PATH"
  fi
}

native_install_claude() {
  if ! command -v curl &>/dev/null; then
    echo "curl not found, skipping native installer."
    return 1
  fi
  echo "Installing Claude Code via native installer..."
  curl -fsSL https://claude.ai/install.sh | bash 2>&1
  # Native installer puts binary in ~/.local/bin
  export PATH="$HOME/.local/bin:$PATH"
  command -v claude &>/dev/null
}

setup_ai_tool() {
  if command -v "$AI_TOOL" &>/dev/null; then
    echo "AI tool '$AI_TOOL' found in PATH."
    return 0
  fi

  echo "AI tool '$AI_TOOL' not found. Attempting auto-install..."
  ensure_writable_home

  case "$AI_TOOL" in
    claude)
      if ! native_install_claude; then
        echo "Native install failed, falling back to npm..."
        install_nodejs
        npm_install_tool @anthropic-ai/claude-code
      fi
      ;;
    codex)
      install_nodejs
      npm_install_tool @openai/codex
      ;;
    amp)
      if ! command -v curl &>/dev/null; then
        echo "ERROR: curl required to install amp. Install curl or use a different image."
        exit 1
      fi
      curl -fsSL https://install.amp.dev | bash 2>&1
      ;;
    *)
      echo "ERROR: Cannot auto-install unsupported AI tool: $AI_TOOL"
      echo "Supported for auto-install: claude, codex, amp"
      exit 1
      ;;
  esac

  # Verify installation succeeded
  if ! command -v "$AI_TOOL" &>/dev/null; then
    echo "ERROR: Failed to install '$AI_TOOL'. It is not in PATH after installation."
    echo "Try using an image with '$AI_TOOL' pre-installed, or install it manually."
    exit 1
  fi

  echo "Successfully installed '$AI_TOOL'."
}

setup_ai_tool

`
}

func scriptAuthCheck() string {
	return `# --- Auth Check: warn if API key is missing ---
check_ai_auth() {
  case "$AI_TOOL" in
    claude)
      if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
        echo "WARNING: ANTHROPIC_API_KEY is not set."
        echo "Claude Code requires authentication. Set the env var before running:"
        echo "  export ANTHROPIC_API_KEY=your-key-here"
      fi
      ;;
    codex)
      if [ -z "${OPENAI_API_KEY:-}" ]; then
        echo "WARNING: OPENAI_API_KEY is not set. Codex requires authentication."
      fi
      ;;
    amp)
      if [ -z "${AMP_API_KEY:-}" ]; then
        echo "WARNING: AMP_API_KEY is not set. Amp requires authentication."
      fi
      ;;
  esac
}

check_ai_auth

`
}

func scriptHelpers() string {
	return `# --- Helpers ---
log() {
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  echo "[$timestamp] $*" | tee -a "$PROGRESS_FILE"
}

get_remaining_tasks() {
  python3 -c "
import json
with open('$PRD_FILE') as f:
    data = json.load(f)
remaining = [t for t in data['tasks'] if t['status'] in ('pending', 'in_progress', 'blocked')]
print(len(remaining))
" 2>/dev/null || echo "unknown"
}

is_all_done() {
  local remaining
  remaining=$(get_remaining_tasks)
  [ "$remaining" = "0" ]
}

`
}

func scriptAIToolFunction() string {
	return `run_ai_tool() {
  case "$AI_TOOL" in
    claude)
      # Claude CLI -p takes a prompt string, not a file path.
      # Read file contents and pass as the prompt argument.
      claude -p "$(cat "$PROMPT_FILE")" --dangerously-skip-permissions
      ;;
    amp)
      amp --prompt-file "$PROMPT_FILE"
      ;;
    cursor)
      echo "Cursor CLI autonomous mode not yet supported. Use claude or amp."
      return 1
      ;;
    codex)
      codex --prompt-file "$PROMPT_FILE" --auto
      ;;
    *)
      echo "ERROR: Unsupported AI tool: $AI_TOOL"
      echo "Supported: claude, amp, codex"
      return 1
      ;;
  esac
}

`
}

func scriptMainLoop() string {
	return `# --- Main Loop ---
log "Auto loop starting. Max iterations: $MAX_ITERATIONS. Tool: $AI_TOOL"
consecutive_failures=0

for ((i = 1; i <= MAX_ITERATIONS; i++)); do
  log "[iteration:$i] Starting iteration $i of $MAX_ITERATIONS"

  if is_all_done; then
    log "[iteration:$i] All tasks completed! Exiting loop."
    break
  fi

  log "[iteration:$i] Running $AI_TOOL..."
  if run_ai_tool; then
    consecutive_failures=0
  else
    consecutive_failures=$((consecutive_failures + 1))
    log "[iteration:$i] ERROR: AI tool exited with error. ($consecutive_failures consecutive)"
    if [ "$consecutive_failures" -ge "$MAX_CONSECUTIVE_FAILURES" ]; then
      log "FATAL: $MAX_CONSECUTIVE_FAILURES consecutive failures reached. Aborting loop."
      log "Check that '$AI_TOOL' is configured correctly (auth, API keys, network)."
      exit 1
    fi
  fi

  sleep "$PAUSE_SECONDS"
  log "[iteration:$i] Iteration $i complete."
done

`
}

func scriptSummary() string {
	return `# --- Summary ---
remaining=$(get_remaining_tasks)
log "Auto loop finished. Iterations run: $((i - 1)). Remaining tasks: $remaining"

if [ "$remaining" = "0" ]; then
  echo "All tasks completed successfully!"
else
  echo "Loop ended with $remaining tasks remaining."
  echo "Run 'samuel auto status' for details."
fi
`
}

// GetSupportedAITools returns the list of supported AI tools
func GetSupportedAITools() []string {
	return []string{"claude", "amp", "cursor", "codex"}
}

// IsValidAITool checks if the given tool name is supported
func IsValidAITool(tool string) bool {
	return slices.Contains(GetSupportedAITools(), strings.ToLower(tool))
}
