package core

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// FolderAnalysis holds the analysis results for a single directory.
type FolderAnalysis struct {
	Path      string
	Name      string
	Languages map[string]int // language name → file count
	Purpose   string
	KeyFiles  []string
	HasTests  bool
	FileCount int
}

// SyncOptions configures the sync operation.
type SyncOptions struct {
	RootDir string
	MaxDepth int // -1 = unlimited
	Force    bool
	DryRun   bool
}

// SyncResult tracks outcomes of the sync operation.
type SyncResult struct {
	Created []string
	Updated []string
	Skipped []string
	Errors  []error
}

// autoGenMarker is the marker used to identify auto-generated CLAUDE.md files.
const autoGenMarker = "<!-- Auto-generated by Samuel"

// extensionLanguageMap maps file extensions to language names.
var extensionLanguageMap = map[string]string{
	".go":    "Go",
	".py":    "Python",
	".ts":    "TypeScript",
	".tsx":   "TypeScript",
	".js":    "JavaScript",
	".jsx":   "JavaScript",
	".rs":    "Rust",
	".java":  "Java",
	".kt":    "Kotlin",
	".kts":   "Kotlin",
	".cs":    "C#",
	".rb":    "Ruby",
	".php":   "PHP",
	".swift": "Swift",
	".dart":  "Dart",
	".lua":   "Lua",
	".r":     "R",
	".R":     "R",
	".c":     "C",
	".h":     "C",
	".cpp":   "C++",
	".hpp":   "C++",
	".cc":    "C++",
	".zig":   "Zig",
	".sol":   "Solidity",
	".cu":    "CUDA",
	".cuh":   "CUDA",
	".sql":   "SQL",
	".sh":    "Shell",
	".bash":  "Shell",
	".zsh":   "Shell",
	".html":  "HTML",
	".css":   "CSS",
	".scss":  "CSS",
	".less":  "CSS",
	".yaml":  "YAML",
	".yml":   "YAML",
	".json":  "JSON",
	".toml":  "TOML",
	".xml":   "XML",
	".md":    "Markdown",
	".proto": "Protobuf",
}

// folderPurposeMap maps folder names to inferred purposes.
var folderPurposeMap = map[string]string{
	"cmd":        "Application entry points and CLI commands.",
	"internal":   "Private application packages (not importable externally).",
	"pkg":        "Public library packages.",
	"api":        "API definitions, schemas, and handlers.",
	"web":        "Web application assets and handlers.",
	"ui":         "User interface components and helpers.",
	"models":     "Data models and domain entities.",
	"handlers":   "Request handlers and controllers.",
	"middleware":  "HTTP/gRPC middleware.",
	"services":   "Business logic and service layer.",
	"repository":  "Data access and storage layer.",
	"config":     "Configuration loading and management.",
	"migrations":  "Database migration files.",
	"scripts":    "Build, deploy, and utility scripts.",
	"tools":      "Development tools and code generators.",
	"test":       "Test files and test utilities.",
	"tests":      "Test files and test utilities.",
	"testdata":   "Test fixture data.",
	"fixtures":   "Test fixture data.",
	"docs":       "Documentation source files.",
	"doc":        "Documentation source files.",
	"assets":     "Static assets (images, fonts, etc.).",
	"static":     "Static files served directly.",
	"public":     "Publicly accessible files.",
	"templates":  "Template files for rendering.",
	"views":      "View templates and layouts.",
	"components": "Reusable UI components.",
	"pages":      "Page-level components or routes.",
	"routes":     "Route definitions.",
	"lib":        "Shared library code.",
	"utils":      "Utility and helper functions.",
	"helpers":    "Helper functions and utilities.",
	"core":       "Core business logic and domain layer.",
	"domain":     "Domain models and business rules.",
	"adapters":   "External service adapters and integrations.",
	"ports":      "Interface definitions (hexagonal architecture).",
	"infra":      "Infrastructure and deployment configuration.",
	"deploy":     "Deployment scripts and configurations.",
	"github":     "GitHub-specific integrations and API clients.",
	"commands":   "CLI command implementations.",
}

// keyFileDescriptions maps key filenames to their descriptions.
var keyFileDescriptions = map[string]string{
	"main.go":        "Entry point",
	"main.py":        "Entry point",
	"index.ts":       "Entry point",
	"index.js":       "Entry point",
	"app.py":         "Application entry point",
	"app.ts":         "Application entry point",
	"app.go":         "Application entry point",
	"server.go":      "Server setup",
	"server.ts":      "Server setup",
	"package.json":   "Node.js package manifest",
	"go.mod":         "Go module definition",
	"Cargo.toml":     "Rust package manifest",
	"pyproject.toml": "Python project configuration",
	"Dockerfile":     "Container build definition",
	"Makefile":       "Build configuration",
	"justfile":       "Just command runner",
	"docker-compose.yml":  "Docker Compose services",
	"docker-compose.yaml": "Docker Compose services",
	".env.example":   "Environment variable template",
	"README.md":      "Documentation",
}

// skipDirSet contains directory names to skip during sync.
var skipDirSet = map[string]bool{
	".git":          true,
	".claude":       true,
	".agent":        true,
	".idea":         true,
	".vscode":       true,
	"node_modules":  true,
	"vendor":        true,
	"__pycache__":   true,
	".venv":         true,
	"venv":          true,
	"env":           true,
	"target":        true,
	"build":         true,
	"dist":          true,
	"out":           true,
	".next":         true,
	".nuxt":         true,
	"coverage":      true,
	".cache":        true,
	".pytest_cache": true,
	".mypy_cache":   true,
	"bin":           true,
	"obj":           true,
	".gradle":       true,
	".maven":        true,
	"site":          true,
	"template":      true,
}

// SyncFolderCLAUDEMDs walks the directory tree and creates/updates
// per-folder CLAUDE.md and AGENTS.md files based on folder analysis.
func SyncFolderCLAUDEMDs(opts SyncOptions) (*SyncResult, error) {
	result := &SyncResult{}

	rootInfo, err := os.Stat(opts.RootDir)
	if err != nil {
		return nil, fmt.Errorf("cannot access root directory: %w", err)
	}
	if !rootInfo.IsDir() {
		return nil, fmt.Errorf("not a directory: %s", opts.RootDir)
	}

	err = filepath.WalkDir(opts.RootDir, func(path string, d os.DirEntry, walkErr error) error {
		if walkErr != nil {
			return nil // skip inaccessible dirs
		}
		if !d.IsDir() {
			return nil
		}

		// Skip root itself
		if path == opts.RootDir {
			return nil
		}

		name := d.Name()

		// Skip hidden directories and known skip dirs
		if ShouldSkipDir(name) {
			return filepath.SkipDir
		}

		// Enforce depth limit
		if opts.MaxDepth >= 0 {
			rel, relErr := filepath.Rel(opts.RootDir, path)
			if relErr != nil {
				result.Errors = append(result.Errors, fmt.Errorf("%s: failed to compute relative path: %w", path, relErr))
				return filepath.SkipDir
			}
			depth := len(strings.Split(rel, string(filepath.Separator)))
			if depth > opts.MaxDepth {
				return filepath.SkipDir
			}
		}

		analysis, analyzeErr := AnalyzeFolder(path)
		if analyzeErr != nil {
			result.Errors = append(result.Errors, fmt.Errorf("%s: %w", path, analyzeErr))
			return nil
		}

		content := GenerateCLAUDEMDContent(analysis)

		// Process CLAUDE.md
		syncFile(path, "CLAUDE.md", content, opts, result)
		// Process AGENTS.md (mirror)
		syncFile(path, "AGENTS.md", content, opts, result)

		return nil
	})

	return result, err
}

// syncFile handles create/update/skip logic for a single file.
func syncFile(dir, filename, content string, opts SyncOptions, result *SyncResult) {
	filePath := filepath.Join(dir, filename)

	existing, err := os.ReadFile(filePath)
	if err != nil {
		// File doesn't exist → create
		if !opts.DryRun {
			if writeErr := os.WriteFile(filePath, []byte(content), 0644); writeErr != nil {
				result.Errors = append(result.Errors, fmt.Errorf("write %s: %w", filePath, writeErr))
				return
			}
		}
		result.Created = append(result.Created, filePath)
		return
	}

	// File exists — check if auto-generated
	if IsAutoGenerated(string(existing)) {
		if !opts.DryRun {
			if writeErr := os.WriteFile(filePath, []byte(content), 0644); writeErr != nil {
				result.Errors = append(result.Errors, fmt.Errorf("write %s: %w", filePath, writeErr))
				return
			}
		}
		result.Updated = append(result.Updated, filePath)
		return
	}

	// User-customized file
	if opts.Force {
		if !opts.DryRun {
			if writeErr := os.WriteFile(filePath, []byte(content), 0644); writeErr != nil {
				result.Errors = append(result.Errors, fmt.Errorf("write %s: %w", filePath, writeErr))
				return
			}
		}
		result.Updated = append(result.Updated, filePath)
		return
	}

	result.Skipped = append(result.Skipped, filePath)
}

// AnalyzeFolder reads a directory and classifies its contents.
func AnalyzeFolder(dirPath string) (*FolderAnalysis, error) {
	entries, err := os.ReadDir(dirPath)
	if err != nil {
		return nil, err
	}

	analysis := &FolderAnalysis{
		Path:      dirPath,
		Name:      filepath.Base(dirPath),
		Languages: make(map[string]int),
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		name := entry.Name()
		ext := strings.ToLower(filepath.Ext(name))

		// Count languages
		if lang, ok := extensionLanguageMap[ext]; ok {
			analysis.Languages[lang]++
			analysis.FileCount++
		}

		// Detect tests
		if isTestFile(name) {
			analysis.HasTests = true
		}

		// Detect key files
		if desc, ok := keyFileDescriptions[name]; ok {
			analysis.KeyFiles = append(analysis.KeyFiles, fmt.Sprintf("`%s` — %s", name, desc))
		}
	}

	// Infer purpose
	analysis.Purpose = inferPurpose(analysis.Name)

	// Sort key files for deterministic output
	sort.Strings(analysis.KeyFiles)

	return analysis, nil
}

// GenerateCLAUDEMDContent builds markdown content from a folder analysis.
func GenerateCLAUDEMDContent(analysis *FolderAnalysis) string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("# %s\n\n", analysis.Name))
	b.WriteString(fmt.Sprintf("%s. Customize with folder-specific instructions. -->\n", autoGenMarker))
	b.WriteString("<!-- AI agents load this file when working in this directory. -->\n")

	// Purpose section
	b.WriteString("\n## Purpose\n\n")
	b.WriteString(analysis.Purpose)
	b.WriteString("\n")

	// Languages section (only if detected)
	if len(analysis.Languages) > 0 {
		b.WriteString("\n## Languages\n\n")
		langs := sortedLanguages(analysis.Languages)
		for _, entry := range langs {
			b.WriteString(fmt.Sprintf("- %s (%d files)\n", entry.name, entry.count))
		}
	}

	// Key files section (only if detected)
	if len(analysis.KeyFiles) > 0 {
		b.WriteString("\n## Key Files\n\n")
		for _, kf := range analysis.KeyFiles {
			b.WriteString(fmt.Sprintf("- %s\n", kf))
		}
	}

	// Tests indicator
	if analysis.HasTests {
		b.WriteString("\n## Testing\n\nThis directory contains test files.\n")
	}

	return b.String()
}

// IsAutoGenerated checks if file content was auto-generated by Samuel.
func IsAutoGenerated(content string) bool {
	return strings.Contains(content, autoGenMarker)
}

// ShouldSkipDir returns true if the directory name should be skipped.
func ShouldSkipDir(name string) bool {
	if strings.HasPrefix(name, ".") {
		return true
	}
	return skipDirSet[name]
}

// isTestFile detects common test file naming patterns.
func isTestFile(name string) bool {
	lower := strings.ToLower(name)
	if strings.HasSuffix(lower, "_test.go") {
		return true
	}
	if strings.HasPrefix(lower, "test_") || strings.HasSuffix(lower, "_test.py") {
		return true
	}
	if strings.Contains(lower, ".test.") || strings.Contains(lower, ".spec.") {
		return true
	}
	return false
}

// inferPurpose returns a purpose string for a folder name.
func inferPurpose(name string) string {
	if purpose, ok := folderPurposeMap[name]; ok {
		return purpose
	}
	return "Package directory."
}

// langEntry is used for sorted language output.
type langEntry struct {
	name  string
	count int
}

// sortedLanguages returns languages sorted by count (desc), then name (asc).
func sortedLanguages(langs map[string]int) []langEntry {
	entries := make([]langEntry, 0, len(langs))
	for name, count := range langs {
		entries = append(entries, langEntry{name, count})
	}
	sort.Slice(entries, func(i, j int) bool {
		if entries[i].count != entries[j].count {
			return entries[i].count > entries[j].count
		}
		return entries[i].name < entries[j].name
	})
	return entries
}
