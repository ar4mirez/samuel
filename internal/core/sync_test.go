package core

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestShouldSkipDir(t *testing.T) {
	tests := []struct {
		name   string
		input  string
		expect bool
	}{
		{"hidden dot dir", ".git", true},
		{"hidden claude dir", ".claude", true},
		{"node_modules", "node_modules", true},
		{"vendor", "vendor", true},
		{"build", "build", true},
		{"dist", "dist", true},
		{"target", "target", true},
		{"__pycache__", "__pycache__", true},
		{"coverage", "coverage", true},
		{"bin", "bin", true},
		{"template", "template", true},
		{"normal dir", "src", false},
		{"internal", "internal", false},
		{"cmd", "cmd", false},
		{"docs", "docs", false},
		{"custom name", "my-package", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ShouldSkipDir(tt.input)
			if got != tt.expect {
				t.Errorf("ShouldSkipDir(%q) = %v, want %v", tt.input, got, tt.expect)
			}
		})
	}
}

func TestIsAutoGenerated(t *testing.T) {
	tests := []struct {
		name    string
		content string
		expect  bool
	}{
		{
			"auto-generated content",
			"# pkg\n\n<!-- Auto-generated by Samuel. Customize with folder-specific instructions. -->\n",
			true,
		},
		{
			"user-customized content",
			"# My Custom Instructions\n\nThis folder handles authentication.\n",
			false,
		},
		{
			"empty content",
			"",
			false,
		},
		{
			"partial marker",
			"<!-- Auto-generated by Some Other Tool -->",
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := IsAutoGenerated(tt.content)
			if got != tt.expect {
				t.Errorf("IsAutoGenerated() = %v, want %v", got, tt.expect)
			}
		})
	}
}

func TestAnalyzeFolder_GoProject(t *testing.T) {
	dir := t.TempDir()
	createFile(t, dir, "main.go", "package main")
	createFile(t, dir, "handler.go", "package main")
	createFile(t, dir, "handler_test.go", "package main")
	createFile(t, dir, "config.yaml", "key: value")
	createFile(t, dir, "Makefile", "build:")

	analysis, err := AnalyzeFolder(dir)
	if err != nil {
		t.Fatalf("AnalyzeFolder() error = %v", err)
	}

	if analysis.Languages["Go"] != 3 {
		t.Errorf("expected 3 Go files, got %d", analysis.Languages["Go"])
	}
	if analysis.Languages["YAML"] != 1 {
		t.Errorf("expected 1 YAML file, got %d", analysis.Languages["YAML"])
	}
	if !analysis.HasTests {
		t.Error("expected HasTests = true")
	}
	if analysis.FileCount != 4 {
		t.Errorf("expected FileCount = 4, got %d", analysis.FileCount)
	}

	keyFileFound := false
	for _, kf := range analysis.KeyFiles {
		if strings.Contains(kf, "main.go") {
			keyFileFound = true
		}
	}
	if !keyFileFound {
		t.Error("expected main.go in key files")
	}
}

func TestAnalyzeFolder_PythonProject(t *testing.T) {
	dir := t.TempDir()
	createFile(t, dir, "app.py", "from flask import Flask")
	createFile(t, dir, "test_app.py", "import pytest")
	createFile(t, dir, "requirements.txt", "flask")

	analysis, err := AnalyzeFolder(dir)
	if err != nil {
		t.Fatalf("AnalyzeFolder() error = %v", err)
	}

	if analysis.Languages["Python"] != 2 {
		t.Errorf("expected 2 Python files, got %d", analysis.Languages["Python"])
	}
	if !analysis.HasTests {
		t.Error("expected HasTests = true")
	}
}

func TestAnalyzeFolder_MixedProject(t *testing.T) {
	dir := t.TempDir()
	createFile(t, dir, "index.ts", "export default {}")
	createFile(t, dir, "styles.css", "body {}")
	createFile(t, dir, "index.test.ts", "test('works', () => {})")
	createFile(t, dir, "package.json", "{}")

	analysis, err := AnalyzeFolder(dir)
	if err != nil {
		t.Fatalf("AnalyzeFolder() error = %v", err)
	}

	if analysis.Languages["TypeScript"] != 2 {
		t.Errorf("expected 2 TypeScript files, got %d", analysis.Languages["TypeScript"])
	}
	if analysis.Languages["CSS"] != 1 {
		t.Errorf("expected 1 CSS file, got %d", analysis.Languages["CSS"])
	}
	if !analysis.HasTests {
		t.Error("expected HasTests = true")
	}
}

func TestAnalyzeFolder_EmptyDir(t *testing.T) {
	dir := t.TempDir()

	analysis, err := AnalyzeFolder(dir)
	if err != nil {
		t.Fatalf("AnalyzeFolder() error = %v", err)
	}

	if len(analysis.Languages) != 0 {
		t.Errorf("expected no languages, got %v", analysis.Languages)
	}
	if analysis.HasTests {
		t.Error("expected HasTests = false")
	}
	if analysis.FileCount != 0 {
		t.Errorf("expected FileCount = 0, got %d", analysis.FileCount)
	}
}

func TestGenerateCLAUDEMDContent_Basic(t *testing.T) {
	analysis := &FolderAnalysis{
		Name:      "handlers",
		Languages: map[string]int{"Go": 5},
		Purpose:   "Request handlers and controllers.",
		FileCount: 5,
	}

	content := GenerateCLAUDEMDContent(analysis)

	assertContains(t, content, "# handlers")
	assertContains(t, content, autoGenMarker)
	assertContains(t, content, "Request handlers and controllers.")
	assertContains(t, content, "Go (5 files)")
}

func TestGenerateCLAUDEMDContent_WithTests(t *testing.T) {
	analysis := &FolderAnalysis{
		Name:      "core",
		Languages: map[string]int{"Go": 10, "YAML": 2},
		Purpose:   "Core business logic and domain layer.",
		HasTests:  true,
		FileCount: 12,
	}

	content := GenerateCLAUDEMDContent(analysis)

	assertContains(t, content, "## Testing")
	assertContains(t, content, "Go (10 files)")
	assertContains(t, content, "YAML (2 files)")
}

func TestGenerateCLAUDEMDContent_WithKeyFiles(t *testing.T) {
	analysis := &FolderAnalysis{
		Name:      "app",
		Languages: map[string]int{"Go": 3},
		Purpose:   "Package directory.",
		KeyFiles:  []string{"`Makefile` — Build configuration", "`main.go` — Entry point"},
		FileCount: 3,
	}

	content := GenerateCLAUDEMDContent(analysis)

	assertContains(t, content, "## Key Files")
	assertContains(t, content, "`main.go` — Entry point")
	assertContains(t, content, "`Makefile` — Build configuration")
}

func TestGenerateCLAUDEMDContent_EmptyDir(t *testing.T) {
	analysis := &FolderAnalysis{
		Name:      "empty",
		Languages: map[string]int{},
		Purpose:   "Package directory.",
	}

	content := GenerateCLAUDEMDContent(analysis)

	assertContains(t, content, "# empty")
	assertContains(t, content, "Package directory.")
	// Should NOT contain language or test sections
	if strings.Contains(content, "## Languages") {
		t.Error("empty dir should not have Languages section")
	}
	if strings.Contains(content, "## Testing") {
		t.Error("empty dir should not have Testing section")
	}
}

func TestSyncFolderCLAUDEMDs_CreateNew(t *testing.T) {
	root := t.TempDir()
	subDir := filepath.Join(root, "pkg")
	mustMkdir(t, subDir)
	createFile(t, subDir, "handler.go", "package pkg")

	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: -1,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	if len(result.Created) != 2 { // CLAUDE.md + AGENTS.md
		t.Errorf("expected 2 created, got %d: %v", len(result.Created), result.Created)
	}

	// Verify files exist
	claudePath := filepath.Join(subDir, "CLAUDE.md")
	agentsPath := filepath.Join(subDir, "AGENTS.md")
	assertFileExists(t, claudePath)
	assertFileExists(t, agentsPath)

	// Verify content matches
	claudeContent, _ := os.ReadFile(claudePath)
	agentsContent, _ := os.ReadFile(agentsPath)
	if string(claudeContent) != string(agentsContent) {
		t.Error("CLAUDE.md and AGENTS.md content should be identical")
	}
}

func TestSyncFolderCLAUDEMDs_UpdateAutoGenerated(t *testing.T) {
	root := t.TempDir()
	subDir := filepath.Join(root, "api")
	mustMkdir(t, subDir)
	createFile(t, subDir, "server.go", "package api")

	// Create existing auto-generated file
	oldContent := "# api\n\n<!-- Auto-generated by Samuel. Customize with folder-specific instructions. -->\n"
	createFile(t, subDir, "CLAUDE.md", oldContent)
	createFile(t, subDir, "AGENTS.md", oldContent)

	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: -1,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	if len(result.Updated) != 2 {
		t.Errorf("expected 2 updated, got %d: %v", len(result.Updated), result.Updated)
	}

	// Verify content was updated with richer analysis
	newContent, _ := os.ReadFile(filepath.Join(subDir, "CLAUDE.md"))
	assertContains(t, string(newContent), "Go (1 files)")
}

func TestSyncFolderCLAUDEMDs_SkipCustom(t *testing.T) {
	root := t.TempDir()
	subDir := filepath.Join(root, "custom")
	mustMkdir(t, subDir)

	// Create user-customized file (no auto-gen marker)
	customContent := "# Custom\n\nMy custom instructions for this folder.\n"
	createFile(t, subDir, "CLAUDE.md", customContent)

	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: -1,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	if len(result.Skipped) != 1 {
		t.Errorf("expected 1 skipped, got %d: %v", len(result.Skipped), result.Skipped)
	}

	// Verify content unchanged
	content, _ := os.ReadFile(filepath.Join(subDir, "CLAUDE.md"))
	if string(content) != customContent {
		t.Error("custom CLAUDE.md should not be modified")
	}
}

func TestSyncFolderCLAUDEMDs_ForceOverwrite(t *testing.T) {
	root := t.TempDir()
	subDir := filepath.Join(root, "custom")
	mustMkdir(t, subDir)

	customContent := "# Custom\n\nMy custom instructions.\n"
	createFile(t, subDir, "CLAUDE.md", customContent)

	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: -1,
		Force:    true,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	if len(result.Updated) < 1 {
		t.Errorf("expected at least 1 updated (forced), got %d", len(result.Updated))
	}

	// Verify content was overwritten
	content, _ := os.ReadFile(filepath.Join(subDir, "CLAUDE.md"))
	if string(content) == customContent {
		t.Error("custom CLAUDE.md should have been overwritten with --force")
	}
}

func TestSyncFolderCLAUDEMDs_DryRun(t *testing.T) {
	root := t.TempDir()
	subDir := filepath.Join(root, "pkg")
	mustMkdir(t, subDir)
	createFile(t, subDir, "lib.go", "package pkg")

	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: -1,
		DryRun:   true,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	if len(result.Created) != 2 {
		t.Errorf("dry-run should report 2 created, got %d", len(result.Created))
	}

	// Verify no files actually created
	claudePath := filepath.Join(subDir, "CLAUDE.md")
	if _, err := os.Stat(claudePath); err == nil {
		t.Error("dry-run should not create files")
	}
}

func TestSyncFolderCLAUDEMDs_DepthLimit(t *testing.T) {
	root := t.TempDir()
	level1 := filepath.Join(root, "pkg")
	level2 := filepath.Join(level1, "sub")
	mustMkdir(t, level1)
	mustMkdir(t, level2)
	createFile(t, level1, "a.go", "package pkg")
	createFile(t, level2, "b.go", "package sub")

	// MaxDepth: 1 should only process level1
	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: 1,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	// Should create CLAUDE.md + AGENTS.md for level1 only
	if len(result.Created) != 2 {
		t.Errorf("depth=1 should create 2 files, got %d: %v", len(result.Created), result.Created)
	}

	assertFileExists(t, filepath.Join(level1, "CLAUDE.md"))
	if _, err := os.Stat(filepath.Join(level2, "CLAUDE.md")); err == nil {
		t.Error("depth=1 should not create files in level2")
	}
}

func TestSyncFolderCLAUDEMDs_SkipHiddenDirs(t *testing.T) {
	root := t.TempDir()
	hidden := filepath.Join(root, ".hidden")
	normal := filepath.Join(root, "src")
	mustMkdir(t, hidden)
	mustMkdir(t, normal)
	createFile(t, hidden, "secret.go", "package hidden")
	createFile(t, normal, "app.go", "package src")

	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: -1,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	// Should only process "src", not ".hidden"
	for _, f := range result.Created {
		if strings.Contains(f, ".hidden") {
			t.Errorf("should not create files in hidden dir: %s", f)
		}
	}
	assertFileExists(t, filepath.Join(normal, "CLAUDE.md"))
}

func TestSyncFolderCLAUDEMDs_NestedDirs(t *testing.T) {
	root := t.TempDir()
	l1 := filepath.Join(root, "internal")
	l2 := filepath.Join(l1, "core")
	l3 := filepath.Join(l2, "models")
	mustMkdir(t, l1)
	mustMkdir(t, l2)
	mustMkdir(t, l3)
	createFile(t, l1, "a.go", "package internal")
	createFile(t, l2, "b.go", "package core")
	createFile(t, l3, "c.go", "package models")

	result, err := SyncFolderCLAUDEMDs(SyncOptions{
		RootDir:  root,
		MaxDepth: -1,
	})
	if err != nil {
		t.Fatalf("SyncFolderCLAUDEMDs() error = %v", err)
	}

	// 3 dirs × 2 files each = 6 created
	if len(result.Created) != 6 {
		t.Errorf("expected 6 created, got %d: %v", len(result.Created), result.Created)
	}
}

// Helper functions

func createFile(t *testing.T, dir, name, content string) {
	t.Helper()
	if err := os.WriteFile(filepath.Join(dir, name), []byte(content), 0644); err != nil {
		t.Fatalf("failed to create file %s: %v", name, err)
	}
}

func mustMkdir(t *testing.T, path string) {
	t.Helper()
	if err := os.MkdirAll(path, 0755); err != nil {
		t.Fatalf("failed to create dir %s: %v", path, err)
	}
}

func assertFileExists(t *testing.T, path string) {
	t.Helper()
	if _, err := os.Stat(path); os.IsNotExist(err) {
		t.Errorf("expected file to exist: %s", path)
	}
}

func assertContains(t *testing.T, content, substr string) {
	t.Helper()
	if !strings.Contains(content, substr) {
		t.Errorf("expected content to contain %q, got:\n%s", substr, content)
	}
}
